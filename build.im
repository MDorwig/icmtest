#!/usr/bin/icmake -qi

#define true  1
#define false 0
#define bool int

#ifdef ECLIPSE
#include "icmaketypes.h"
#endif
#define COLORED
#ifdef COLORED
#define VT100_Reset      "\33[0m"
#define VT100_Fg_Black   "\33[30m"
#define VT100_Fg_Red     "\33[31m"
#define VT100_Fg_Green   "\33[32m"
#define VT100_Fg_Yellow  "\33[33m"
#define VT100_Fg_Blue    "\33[34m"
#define VT100_Fg_Magenta "\33[35m"
#define VT100_Fg_Cyan    "\33[36m"
#define VT100_Fg_White   "\33[37m"

#define VT100_Bg_Black   "\33[40m"
#define VT100_Bg_Red     "\33[41m"
#define VT100_Bg_Green   "\33[42m"
#define VT100_Bg_Yellow  "\33[43m"
#define VT100_Bg_Blue    "\33[44m"
#define VT100_Bg_Magenta "\33[45m"
#define VT100_Bg_Cyan    "\33[46m"
#define VT100_Bg_White   "\33[47m"
#else
#define VT100_Reset
#define VT100_Fg_Black
#define VT100_Fg_Red
#define VT100_Fg_Green
#define VT100_Fg_Yellow
#define VT100_Fg_Blue
#define VT100_Fg_Magenta
#define VT100_Fg_Cyan
#define VT100_Fg_White

#define VT100_Bg_Black
#define VT100_Bg_Red
#define VT100_Bg_Green
#define VT100_Bg_Yellow
#define VT100_Bg_Blue
#define VT100_Bg_Magenta
#define VT100_Bg_Cyan
#define VT100_Bg_White
#endif

int 	echostate = ON;
int 	trace;
list  cflags;
list  cxxflags;
list  ldflags;

bool setecho(bool b)
{
	bool r ;
  string s ;
	r = echostate;
	echostate=b;
	echo(b);
#ifdef DEBUG
	if (echostate)
	  s = "ON" ;
	else
	  s ="OFF";
	printf("echo is %1\n",s);

#endif
	return r;
}

bool getecho()
{
	return echostate == ON;
}

list capture(string cmd)
{
	if (trace)
		printf("capture(%1)\n",cmd);
	return `cmd`;
}

void maybe_exec(int dryrun,string cmd)
{
	if (!dryrun)
		exec(P_CHECK,cmd);
	else
		printf("dry:%1\n",cmd);
}

void rm(int dryrun,string opt,string args)
{
	string cmd ;
	cmd = strformat("rm %1 %2",opt,args);
	maybe_exec(dryrun,cmd);
}

void mkdir(int dryrun,string opt,string args)
{
	string cmd ;
	cmd = strformat("mkdir %1 %2",opt,args);
	maybe_exec(dryrun,cmd);
}

/*
 * this function parses a compiler generated dependecy file (*.d)
 * dependency files contain lines in the form:
 * target1 target2: dependency1 dependency2 ...
 * if the dependencyfile or the objectfile do not exist the function returns true
 * if the targets do not exist the function returns true
 * if one of the dependenies is younger than the objectfile the function returns true 
 */
bool MustBuild(int trace,string objfile)
{
	string depfile;
	string f;
	string s ;
	string rule;
	string text;
	
	list targets ;
	list line;
	list deps;
	
	int i ;
	depfile = change_ext(objfile,"d");
	if (!exists(objfile))
	{
		if (trace)
			printf("Must build %1 because it does not exist\n",objfile);
		return true ;
	}
	if (!exists(depfile))
	{
		if (trace)
			printf("Must build %2 because %1 does not exist\n",depfile,objfile);
		return true ;
	}
	while(1)
	{
		line = fgets(depfile,(int)line[1]);
		if (line.length == 0)
			break ;
		if (trace)
			printf("read %1",line[0]);
		text = trim(line[0]);
		if (text.length > 0)
		{
			if (text[text.length-1] == "\\")
			{
				rule += trim(substr(text,0,text.length-1));
				rule += " ";
			}
			else
			{
				rule += text;
				if (trace)
					printf("rule %1\n",rule);
				i = strfind(rule,":");
				if (i != -1)
				{
					f = substr(rule,0,i);
					s = trim(substr(rule,i+1,rule.length-i));
					targets = strtok(f," ");
					for (i = 0 ; i < targets.length ; i++)
					{
						if (!exists(targets[i]))
						{
							if (trace)
								printf("Must build %2 because %1 does not exist\n",targets[i],objfile);
							return true;
						}
					}
					deps = strtok(s," ");
					for (i = 0 ; i < deps.length ; i++)
					{
						if (trace)
							printf("check %1 against %2\n",deps[i],objfile);
						if (deps[i] younger objfile)
						{
							if (trace)
								printf("Must build %2 because %1 is younger\n",deps[i],objfile);
							return true ;
						}
					}
				}
				rule = "";
			}
		}
	}
	if (trace)
		printf("Must not build %1\n",objfile);
	return false;
}


string gitrev()
{
	list res ;
	int ec ;
	string version ;
	ec = setecho(OFF);
	res  = capture("git name-rev --name-only HEAD");
	res += capture("git rev-parse --verify --short HEAD");
	setecho(ec);
	version = strformat("%1-%2",trimright(res[0]),trimright(res[1])) ;
	return version;
}

void Compile(int dryrun,string prefix,string src,string obj)
{
	string dfile,depopt,cmd;
	string options;
  string cxx ;
	dfile= change_ext(obj,"d");
	if (get_ext(src) == "c")
	{
	  cxx = "gcc" ;
	  options = strformat("%1",cflags);
	}
	else
	{
	  cxx = "g++" ;
		options = strformat("%1",cxxflags);
	}
	depopt = strformat("-MMD -MP -MF%1  -MT%1",dfile);
	cmd =strformat("%1%2 %3 -c %4 -o %5 %6",prefix,cxx,options,src,obj,depopt);
	if (!getecho())
		printf(VT100_Fg_White "compiling %1" VT100_Reset "\n",obj);
	maybe_exec(dryrun,cmd);
}

list ParseMakefileLine(string line)
{
	list lst ;
	int i ;
	i = strfind(line,"]");
	if (i != -1)
	{
		lst = strtok(substr(line,1,i-1)," \t");
	}
}

list ReadMakefile(string file,string config,string host)
{
	list src ;
	list pos ;
	list sec_cfg;
	string section;
  string line ;

  int linecnt ;
	int i ;
	if (trace)
	{
	  printf("config=%1\n",config);
    printf("host=%1\n",host);
	}
  while(1)
  {
    pos = fgets(file,(int)pos[1]);
    if (pos.length == 0)
    {
      break;
    }
    linecnt++;
    line = trim(pos[0]);
    if (line.length != 0 && line[0] != "#") 
    {
    	if (line[0] == "[")
    	{
    		sec_cfg = ParseMakefileLine(line);
    		if (sec_cfg.length == 0)
  			{
  				printf("syntax error in %1 %2:%3",file,linecnt,line);
  				exit(1);
  			}
  			printf("section=%1\n",sec_cfg);
    	}
    	else if (sec_cfg[1] == "COMMON" || sec_cfg[1] == config || sec_cfg[1] == host)
			{
				if (sec_cfg[0] == "FILES")
				{
					src += strtok(line," \t");
				}
				else if (sec_cfg[0] == "CFLAGS")
				{
					cflags += strtok(line," \t");
				}
				else if (sec_cfg[0] == "CXXFLAGS")
				{
					cxxflags += strtok(line," \t");
				}
				else if (sec_cfg[0] == "LDFLAGS")
				{
					ldflags += strtok(line," \t");
				}
			}
    }
	}
	return src;
}

void Link(int dryrun,string prefix,list objects,string output)
{
	string cmd ;
	cmd = strformat("%1g++ -o %2 %3 %4",prefix,output,objects,strformat("%1",ldflags));
	if (!getecho())
		printf(VT100_Fg_White "linking   %1" VT100_Reset "\n",output);
	maybe_exec(dryrun,cmd);
}

bool CheckCompiler(string cc)
{
	int es ;
	int i ;
	list res ;
	string output;
	string gccver;
	es = setecho(OFF);
	if (trace)
		printf("ckeck for compiler %1gcc\n",cc);
	res = capture(cc+"gcc --version 2>&1");
	for(i = 0 ; i < res.length ; i++)
		output += res[i];
	res = strtok(output,"\n");
	i = strfind(res[0],"(GCC)");
	if (i != -1)
	{
		if (trace)
			printf("found %1\n",res[0]);
	}
	setecho(es);
	return i != -1 ;
}

string MachineName()
{
  list res ;
  int e = setecho(OFF);
  res = capture("uname -m");
  setecho(e);
  return trim(res[0]);
}

#define CONFIG_OPT    "--config="
#define HOST_OPT      "--host="
#define ARTIFACT_OPT  "--artifact="

void main (int argc,list argv)
{
    list srcfiles;
    list objfiles;
    int i;
    int j;
    int clean;
    int dryrun;
    string arg;
    string dir;
    string sourcefile;
    string objfile;
    string bindir       = "bin";
  	string cleancmd ;
    string crosscompile;
    string host;
    string config       = "debug";
    string versionfile  = "version.h";
    string gitversion;
    string outputfile;
    string makefile = "makefile.icm";

    setecho(ON);
    for (i = 1 ; i < argv.length-1 ; i++)
    {
    	arg = argv[i];
    	if (arg.length)
    	{
				if (arg == "clean")
				{
					clean = 1;
				}
				else if (arg == "-f")
				{
					if (i+1 < argv.length-1)
					{
						makefile = argv[++i];
					}
					else
					{
						printf(VT100_Fg_Red "you must specify the name of a controlfile" VT100_Reset "\n");
						exit(1);
					}
				}
				else if (arg == "-dry")
				{
					dryrun = ON;
				}
				else if (arg == "-trace")
				{
					trace = true;
				}
				else if ((j = strfind(arg,HOST_OPT)) == 0)
				{
					host = substr(arg,HOST_OPT.length,arg.length);
					crosscompile = host+"-";
				}
				else if ((j = strfind(arg,CONFIG_OPT)) == 0)
				{
					config = substr(arg,CONFIG_OPT.length,arg.length);
					if (config.length == 0)
					{
						printf("you must specify a configuration like %1debug or %1release\n",CONFIG_OPT);
						exit(1);
					}
				}
				else if ((j = strfind(arg,ARTIFACT_OPT)) == 0)
				{
					outputfile = substr(arg,ARTIFACT_OPT.length,arg.length);
					if (outputfile.length == 0)
					{
						printf("you must specify an artifact\n");
						exit(1);
					}
				}
				else
				{
					printf("unknown argument \"%1\"\n",arg);
					exit(1);
				}
    	}
    }
    if (!exists(makefile))
    {
    	printf("%1 does not exist\n",makefile);
    	exit(1);
    }
    if (crosscompile.length != 0 && CheckCompiler(crosscompile) == false)
    {
    	printf("compiler %1gcc does not exist\n",crosscompile);
    	exit(1);
    }
    if (host.length == 0)
    {
      host = MachineName();
    }
    
    
    srcfiles = ReadMakefile(makefile,config,host);
    if (trace)
    {
    	printf("srcfiles:%1\ncflags=%2\ncxxflags=%3\nldflags=%4\n",srcfiles,cflags,cxxflags,ldflags);
    }
    gitversion = gitrev();
    if (trace)
    	printf("git rev :\"%1\"\n",gitversion);
    rm(dryrun,"-f",versionfile);
    fprintf(versionfile,"#ifndef VERSION_H_INCLUDED\n");
    fprintf(versionfile,"#define VERSION_H_INCLUDED\n\n");
    fprintf(versionfile,"#define GIT_VERSION \"%1\"\n\n",gitversion);
    fprintf(versionfile,"#endif\n");
    bindir += strformat("/%1",config);
    if (trace)
      printf("bindir = %1\n",bindir);
    if (!exists(bindir))
    	maybe_exec(false,strformat("mkdir -p %1",bindir));

    if (outputfile.length == 0)
    	outputfile="output";
   	outputfile = strformat("%1/%2",bindir,outputfile);
    if (clean)
    {
    	rm(dryrun,"-rf",bindir+"/*");
    }
    else
    {
			if (srcfiles.length)
			{
					for (i = 0; i < srcfiles.length ; i++)  
					{
							sourcefile = trim(element (i, srcfiles));   // get the name from the list
							objfile = change_ext(strformat("%1/%2",bindir,sourcefile),"o");
							dir = get_path(objfile);
							if (!exists(dir))
								mkdir(false,"-p",dir);
							if (MustBuild(trace,objfile))
							{
								Compile(dryrun,crosscompile,sourcefile,objfile);
							}
							objfiles += (list)objfile;
					}
					Link(dryrun,crosscompile,objfiles,outputfile);
			}
    }
}

